/**
 * Script Combinado para Google Sheets: Gesti√≥n del Calendario Cultural Estrat√©gico (con campos internos),
 * Cronograma Editorial y Generador de Presentaciones del CECAN.
 * (Versi√≥n con campos de gesti√≥n interna y presentaci√≥n adaptada)
 */

const CONFIG = {
  calendarSheet: {
    name: "Calendario Cultural CECAN",
    columns: {
      folio: { label: "Folio", index: 0 },
      idEvento: { label: "ID Evento", index: 1 },
      mes: { label: "Mes", index: 2 },
      dia: { label: "D√≠a", index: 3 },
      fechaCompleta: { label: "Fecha Completa", index: 4 },
      evento: { label: "Evento / Actividad", index: 5 },
      tipoActividad: { label: "Tipo Actividad", index: 6 },
      alcance: { label: "Alcance", index: 7 },
      relevanciaCultural: { label: "Relevancia Cultural (P√∫blico)", index: 8 },
      descripcionInterna: { label: "Descripci√≥n (Interna)", index: 9 },
      sugerenciasCecan: { label: "Sugerencias CECAN (P√∫blico)", index: 10 },
      proyectosCecan: { label: "Proyectos CECAN Vinculados", index: 11 },
      areaResponsable: { label: "√Årea Responsable CECAN", index: 12 },
      lugarEspecifico: { label: "Lugar Espec√≠fico", index: 13 },
      horaInicio: { label: "Hora Inicio", index: 14 },
      horaFin: { label: "Hora Fin", index: 15 },
      prioridad: { label: "Prioridad", index: 16 },
      alineacionPsectorial: { label: "Alineaci√≥n PSECTORIAL", index: 17 },
      metaPsectorialNo: { label: "Meta PSECTORIAL No.", index: 18 },
      estadoContenidoExt: { label: "Estado Contenido (Externo)", index: 19 },
      estadoInterno: { label: "Estado Interno", index: 20 },
      estadoVerificacionExt: { label: "Estado Verificaci√≥n (Externo)", index: 21 }
    },
    defaultSort: [
      { columnKey: 'fechaCompleta', ascending: true },
      { columnKey: 'horaInicio', ascending: true }
    ],
    status: { 
      PENDIENTE: "Pendiente",
      EN_PROCESO: "En Proceso",
      LISTO: "Listo",
      PUBLICADO: "Publicado"
    },
    statusColors: {
      PENDIENTE: "#FFF2CC" 
    },
    dropdownLists: {
      tiposActividad: ["Evento P√∫blico", "Conmemoraci√≥n Externa", "Reuni√≥n Interna", "Capacitaci√≥n", "Hito de Proyecto", "Entrega Administrativa", "Log√≠stica Evento", "Otro"],
      prioridad: ["Alta", "Media", "Baja"],
      estadoInterno: ["Planeado", "Confirmado", "En Log√≠stica", "En Ejecuci√≥n", "Completado", "Pospuesto", "Cancelado"],
      alcance: ["Mundial", "Nacional", "Estatal (Nayarit)", "Municipal", "Comunitario", "Interno CECAN", "Interinstitucional"]
    },
    get headerNames() { 
      return Object.values(this.columns)
                   .sort((a, b) => a.index - b.index)
                   .map(col => col.label);
    },
    numberFormats: {
      fechaCompleta: "yyyy-mm-dd",
      horaInicio: "hh:mm AM/PM",
      horaFin: "hh:mm AM/PM"
    }
  },
  editorialSheet: {
    name: "Cronograma Editorial",
    styling: {
      headerColor: "#e2d8f3",
      bandingColor1: "#ffffff",
      bandingColor2: "#f3f6f4",
      borderColor: "#d9d9d9"
    },
    columns: {
      idEvento: { label: "ID Evento (Opcional)", index: 0 },
      fechaEvento: { label: "Fecha Evento", index: 1 },
      eventoConmemoracion: { label: "Evento/Conmemoraci√≥n", index: 2 },
      fechaPublicacion: { label: "Fecha Publicaci√≥n", index: 3 },
      horaPublicacion: { label: "Hora Publicaci√≥n", index: 4 },
      plataforma: { label: "Plataforma", index: 5 },
      textoContenidoRef: { label: "Texto/Contenido (Ref)", index: 6 },
      visualRef: { label: "Visual (Ref)", index: 7 },
      estadoPublicacion: { label: "Estado Publicaci√≥n", index: 8 },
      responsableOpc: { label: "Responsable (Opc.)", index: 9 },
      notasEspecificas: { label: "Notas Espec√≠ficas", index: 10 }
    },
    get headerNames() { 
        return Object.values(this.columns)
                     .sort((a, b) => a.index - b.index)
                     .map(col => col.label);
    },
    dropdownLists: {
      plataforma: ["Facebook", "Instagram Feed", "Instagram Story", "Instagram Reel", "X (Twitter)", "LinkedIn", "TikTok", "YouTube", "Web CECAN", "Telegram", "WhatsApp Status", "Otro"],
      estadoPublicacion: ["Pendiente", "En Proceso", "Listo para Programar", "Programado", "Publicado", "Cancelado"]
    },
    conditionalFormattingStatusColors: {
      "Pendiente": "#fffacd",
      "En Proceso": "#fffacd", 
      "Listo para Programar": "#fffacd", 
      "Programado": "#cfe2f3", 
      "Publicado": "#d9ead3", 
      "Cancelado": "#cccccc"
    },
    columnWidths: [100, 120, 250, 120, 100, 150, 250, 200, 150, 120, 300],
    numberFormatColumns: {
        fechaEvento: "yyyy-mm-dd",
        fechaPublicacion: "yyyy-mm-dd"
    }
  },
  internalPresentation: {
    titleFontFamily: "Calibri",
    titleFontSize: 28,
    titleFontColor: "#222222",
    titleShapeFillColor: "#e0e0e0",
    titleShapePadding: 10,
    bodyFontFamily: "Calibri",
    bodyFontSize: 12,
    bodyFontColor: "#333333",
    backgroundColor: "#f5f5f5",
    accentColors: {
      prioridadAlta: "#E53935", 
      prioridadMedia: "#FFB300", 
      prioridadBaja: "#43A047" 
    },
    requiredCalendarColumns: [ 
      "folio", "mes", "fechaCompleta", "evento", "tipoActividad",
      "descripcionInterna", "areaResponsable", "lugarEspecifico",
      "horaInicio", "horaFin", "prioridad", "alineacionPsectorial",
      "metaPsectorialNo", "estadoInterno"
    ],
    endSlideText: "CECAN - Planificaci√≥n Interna"
  }
};

// --- Helper Functions for Sheet Setup ---

/**
 * Ensures a sheet with the given name exists, creating it if necessary, and sets its headers.
 * @param {string} sheetName The name of the sheet to ensure exists.
 * @param {string[]} headersArray An array of strings for the header row.
 * @param {boolean} headerBold If true, the header row will be bold.
 * @param {GoogleAppsScript.Spreadsheet.Spreadsheet} targetSpreadsheet The spreadsheet to work with.
 * @returns {{sheet: GoogleAppsScript.Spreadsheet.Sheet, isNew: boolean}} An object containing the sheet and a boolean indicating if it was newly created.
 */
function ensureSheetExists(sheetName, headersArray, headerBold, targetSpreadsheet) {
  let sheet = targetSpreadsheet.getSheetByName(sheetName);
  let isNewSheet = false;
  if (!sheet) {
    sheet = targetSpreadsheet.insertSheet(sheetName);
    Logger.log(`Hoja '${sheetName}' creada.`);
    isNewSheet = true;
  } else {
    Logger.log(`Hoja '${sheetName}' ya existe.`);
  }

  if (sheet.getLastColumn() < headersArray.length) {
    sheet.insertColumnsAfter(sheet.getLastColumn(), headersArray.length - sheet.getLastColumn());
  }
  const headerRange = sheet.getRange(1, 1, 1, headersArray.length);
  headerRange.setValues([headersArray]);
  if (headerBold) {
    headerRange.setFontWeight("bold");
  }
  Logger.log(`Encabezados verificados/escritos en ${sheetName}`);
  return {sheet: sheet, isNew: isNewSheet};
}

/**
 * Populates a sheet with initial data if the sheet is empty (has less than 2 rows).
 * @param {GoogleAppsScript.Spreadsheet.Sheet} sheet The sheet to populate.
 * @param {Array<Array<string|Date|number>>} dataArray A 2D array of data to insert.
 * @param {string[]} headerArray An array of header strings (used to determine number of columns).
 * @returns {void}
 */
function populateInitialData(sheet, dataArray, headerArray) {
  if (sheet.getLastRow() < 2 && dataArray.length > 0) {
    sheet.getRange(2, 1, dataArray.length, headerArray.length).setValues(dataArray);
    Logger.log(`Datos iniciales poblados en ${sheet.getName()}`);
  } else if (dataArray.length > 0) {
    Logger.log(`La hoja ${sheet.getName()} ya contiene datos. No se a√±adieron los datos iniciales.`);
  }
}

/**
 * Applies conditional formatting rules to a sheet.
 * @param {GoogleAppsScript.Spreadsheet.Sheet} sheet The sheet to apply rules to.
 * @param {object[]} rulesConfigs An array of rule configuration objects.
 * @param {object} columnObjects Configuration object for sheet columns, mapping keys to {index, label}.
 * @param {string[]} [clearOnlyTheseColumnKeys] Optional. An array of column keys for which to clear existing rules before applying new ones. If null/empty, existing rules are preserved unless directly replaced by a new rule with identical range and type.
 * @returns {void}
 */
function applyConditionalFormattingRules(sheet, rulesConfigs, columnObjects, clearOnlyTheseColumnKeys) {
  let existingRules = sheet.getConditionalFormatRules();
  let newRules = [];

  if (clearOnlyTheseColumnKeys && clearOnlyTheseColumnKeys.length > 0) {
    const targetColumnIndices = clearOnlyTheseColumnKeys.map(key => columnObjects[key].index + 1);
    existingRules.forEach(rule => {
      let ruleAppliesToTarget = false;
      const ranges = rule.getRanges();
      if (ranges) {
        for (let j = 0; j < ranges.length; j++) {
          if (ranges[j].getSheet().getName() === sheet.getName() && targetColumnIndices.includes(ranges[j].getColumn())) {
            ruleAppliesToTarget = true;
            break;
          }
        }
      }
      if (!ruleAppliesToTarget) {
        newRules.push(rule);
      }
    });
  } else {
     newRules = existingRules.slice(); // Create a copy to modify
  }
  
  rulesConfigs.forEach(function(ruleConfig) {
    const columnIndex = columnObjects[ruleConfig.columnKey].index + 1;
    const range = sheet.getRange(2, columnIndex, sheet.getMaxRows() - 1, 1);
    const ruleBuilder = SpreadsheetApp.newConditionalFormatRule().setRanges([range]);

    if (ruleConfig.criteriaType === SpreadsheetApp.BooleanCriteria.TEXT_EQ) {
        ruleBuilder.whenTextEqualTo(ruleConfig.criteriaValue);
    }
    // Add other criteria types as needed in future

    if (ruleConfig.backgroundColor) {
        ruleBuilder.setBackground(ruleConfig.backgroundColor);
    }
    if (ruleConfig.fontColor) {
        ruleBuilder.setFontColor(ruleConfig.fontColor);
    }
    newRules.push(ruleBuilder.build());
  });

  sheet.setConditionalFormatRules(newRules);
  Logger.log(`Formato condicional actualizado en ${sheet.getName()}`);
}

/**
 * Applies data validation rules to specified columns in a sheet.
 * @param {GoogleAppsScript.Spreadsheet.Sheet} sheet The sheet to apply data validations to.
 * @param {object[]} validationsConfigs An array of validation configuration objects.
 * @param {object} columnObjects Configuration object for sheet columns, mapping keys to {index, label}.
 * @param {object} allDropdownLists An object where keys are list identifiers and values are arrays of dropdown options or objects (like CONFIG.calendarSheet.status).
 * @returns {void}
 */
function applyDataValidations(sheet, validationsConfigs, columnObjects, allDropdownLists) {
  validationsConfigs.forEach(function(valConfig) {
    const columnIndex = columnObjects[valConfig.columnKey].index + 1;
    const range = sheet.getRange(2, columnIndex, sheet.getMaxRows() - 1, 1);
    const listSource = allDropdownLists[valConfig.requireValueInList.listKey];
    const validationList = Array.isArray(listSource) ? listSource : Object.values(listSource);
    
    const rule = SpreadsheetApp.newDataValidation()
      .requireValueInList(validationList)
      .setAllowInvalid(valConfig.requireValueInList.allowInvalid)
      .setHelpText(valConfig.requireValueInList.helpText)
      .build();
    range.setDataValidation(rule);
  });
  Logger.log(`Validaci√≥n de datos configurada en ${sheet.getName()}`);
}

/**
 * Applies number formats to specified columns in a sheet.
 * @param {GoogleAppsScript.Spreadsheet.Sheet} sheet The sheet to apply number formats to.
 * @param {object} formatsConfigs An object where keys are column keys (from columnObjects) and values are number format strings.
 * @param {object} columnObjects Configuration object for sheet columns, mapping keys to {index, label}.
 * @returns {void}
 */
function applyNumberFormats(sheet, formatsConfigs, columnObjects) {
  for (const columnKey in formatsConfigs) {
    if (formatsConfigs.hasOwnProperty(columnKey) && columnObjects[columnKey]) {
      const columnIndex = columnObjects[columnKey].index + 1;
      const range = sheet.getRange(2, columnIndex, sheet.getMaxRows() - 1, 1);
      range.setNumberFormat(formatsConfigs[columnKey]);
    }
  }
  Logger.log(`Formatos de n√∫mero aplicados en ${sheet.getName()}`);
}

/**
 * Auto-resizes all columns in a sheet based on their content.
 * @param {GoogleAppsScript.Spreadsheet.Sheet} sheet The sheet to resize columns on.
 * @param {string[]} headerArray An array of header strings (used to determine the number of columns to resize).
 * @returns {void}
 */
function autoResizeAllColumns(sheet, headerArray) {
  try {
    headerArray.forEach(function(_, i) {
      sheet.autoResizeColumn(i + 1);
    });
    Logger.log(`Columnas auto-ajustadas en ${sheet.getName()}`);
  } catch (e) {
    Logger.log(`Error en autoResizeColumn (puede ignorarse) en ${sheet.getName()}: ${e.toString()}`);
  }
}

/**
 * Applies specific styling to the Editorial Sheet.
 * @param {GoogleAppsScript.Spreadsheet.Sheet} sheet The Editorial sheet.
 * @param {object} stylingConfig Configuration object for styling (headerColor, bandingColors, borderColor).
 * @param {number[]} colWidthsArray Array of column widths.
 * @param {number} numHeaders The number of header columns.
 * @returns {void}
 */
function applyEditorialSheetStyling(sheet, stylingConfig, colWidthsArray, numHeaders) {
  const headerRange = sheet.getRange(1, 1, 1, numHeaders);
  headerRange
    .setBackground(stylingConfig.headerColor)
    .setVerticalAlignment("middle")
    .setHorizontalAlignment("center")
    .setWrapStrategy(SpreadsheetApp.WrapStrategy.WRAP)
    .setBorder(null, null, true, null, null, null, stylingConfig.borderColor, SpreadsheetApp.BorderStyle.SOLID_MEDIUM);
  
  sheet.setFrozenRows(1);

  const dataRange = sheet.getRange(2, 1, sheet.getMaxRows() - 1, numHeaders);
  const existingBandings = sheet.getBandings();
  for (let i = 0; i < existingBandings.length; i++) {
    existingBandings[i].remove();
  }
  const banding = dataRange.applyRowBanding(SpreadsheetApp.BandingTheme.LIGHT_GREY);
  banding.setHeaderRowColor(null) 
         .setFirstRowColor(stylingConfig.bandingColor1)
         .setSecondRowColor(stylingConfig.bandingColor2);
  
  dataRange.setBorder(true, true, true, true, true, true, stylingConfig.borderColor, SpreadsheetApp.BorderStyle.SOLID_THIN);

  colWidthsArray.forEach((width, i) => {
    sheet.setColumnWidth(i + 1, width);
  });
  Logger.log(`Estilos aplicados a la hoja: ${sheet.getName()}`);
}

// --- Helper Functions for Presentation Generation ---

/**
 * Retrieves and prepares calendar data for a specific month.
 * @param {string} calendarSheetName The name of the calendar sheet.
 * @param {string} requestedMonth The month for which to filter data (e.g., "Junio").
 * @param {object} sheetColumnsConfig The column configuration object for the calendar sheet.
 * @param {string[]} requiredColumnKeys An array of column keys that are essential for the presentation.
 * @returns {object[]|null} An array of event objects for the month, or null if an error occurs.
 */
function getCalendarDataForMonth(calendarSheetName, requestedMonth, sheetColumnsConfig, requiredColumnKeys) {
  const ui = SpreadsheetApp.getUi();
  const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
  const calendarSheet = spreadsheet.getSheetByName(calendarSheetName);

  if (!calendarSheet) {
    ui.alert(`Error: No se encontr√≥ la hoja de calendario "${calendarSheetName}".`);
    Logger.log(`Error: Hoja de calendario "${calendarSheetName}" no encontrada.`);
    return null;
  }

  const allSheetData = calendarSheet.getDataRange().getValues();
  if (allSheetData.length === 0) {
    ui.alert(`Error: La hoja de calendario "${calendarSheetName}" est√° vac√≠a.`);
    Logger.log(`Error: Hoja de calendario "${calendarSheetName}" vac√≠a.`);
    return null;
  }
  const sheetHeaders = allSheetData.shift();
  
  const idxMap = {};
  for (const key of requiredColumnKeys) {
    if (!sheetColumnsConfig[key] || !sheetColumnsConfig[key].label) {
        const errorMsg = `Error de Configuraci√≥n: Falta la configuraci√≥n para la columna requerida con clave "${key}".`;
        ui.alert(errorMsg);
        Logger.log(errorMsg);
        return null;
    }
    const label = sheetColumnsConfig[key].label;
    const index = sheetHeaders.indexOf(label);
    if (index === -1) {
      const errorMsg = `Error de Columnas: La columna requerida "${label}" (clave: ${key}) no se encontr√≥ en la hoja "${calendarSheetName}". Revisa los encabezados.`;
      ui.alert(errorMsg);
      Logger.log(errorMsg);
      return null;
    }
    idxMap[key] = index;
  }

  for (const key in sheetColumnsConfig) {
    if (!idxMap.hasOwnProperty(key)) { 
        const label = sheetColumnsConfig[key].label;
        idxMap[key] = sheetHeaders.indexOf(label); 
    }
  }
  
  if (idxMap.mes === -1 || typeof idxMap.mes === 'undefined') {
      const errorMsg = `Error de Columnas: La columna "Mes" (clave: mes) no se encontr√≥ o no est√° configurada correctamente en la hoja "${calendarSheetName}".`;
      ui.alert(errorMsg);
      Logger.log(errorMsg);
      return null;
  }

  const eventosDelMesData = allSheetData.filter(row => row[idxMap.mes] && row[idxMap.mes].toString().toLowerCase() === requestedMonth.toLowerCase());

  const eventosDelMesObjects = eventosDelMesData.map(row => {
    const eventObj = {};
    for (const key in sheetColumnsConfig) { // Iterate over all configured columns
      if (idxMap.hasOwnProperty(key) && idxMap[key] !== -1) { // Check if key exists in idxMap and was found
        eventObj[key] = row[idxMap[key]];
      }
    }
    return eventObj;
  });
  Logger.log(`Se encontraron ${eventosDelMesObjects.length} eventos para el mes de ${requestedMonth}.`);
  return eventosDelMesObjects;
}

/**
 * Adds and formats the title slide of a presentation.
 * @param {GoogleAppsScript.Slides.Presentation} presentation The presentation object.
 * @param {string} presentationTitle The main title for the presentation.
 * @param {string} subtitleText The subtitle text.
 * @param {object} styleConfig Configuration object for presentation styling.
 * @returns {void}
 */
function addTitleSlideToPresentation(presentation, presentationTitle, subtitleText, styleConfig) {
  const slide = presentation.getSlides()[0]; 
  slide.getBackground().setSolidFill(styleConfig.backgroundColor);

  slide.getPlaceholders().forEach(ph => {
    if (ph.getPlaceholderType() === SlidesApp.PlaceholderType.TITLE) {
      ph.asShape().getText().setText(presentationTitle)
        .getTextStyle().setFontFamily(styleConfig.titleFontFamily)
        .setFontSize(styleConfig.titleFontSize)
        .setForegroundColor(styleConfig.titleFontColor);
    } else if (ph.getPlaceholderType() === SlidesApp.PlaceholderType.SUBTITLE) {
      ph.asShape().getText().setText(subtitleText)
        .getTextStyle().setFontFamily(styleConfig.bodyFontFamily) 
        .setFontSize(styleConfig.bodyFontSize)    
        .setForegroundColor(styleConfig.bodyFontColor);
    } else {
      try { 
          ph.asShape().getText().setText(""); 
      } catch(e) {
          Logger.log(`Advertencia: No se pudo limpiar el placeholder: ${e.toString()}`);
      }
    }
  });
  Logger.log("Diapositiva de t√≠tulo agregada y formateada.");
}

/**
 * Adds a new slide to the presentation for a single event.
 * @param {GoogleAppsScript.Slides.Presentation} presentation The presentation object.
 * @param {object} eventObj An object containing the event's data.
 * @param {object} styleConfig Configuration object for presentation styling.
 * @param {GoogleAppsScript.Slides.PredefinedLayout} layout The layout to use for the new slide.
 * @returns {void}
 */
function addEventSlideToPresentation(presentation, eventObj, styleConfig, layout) {
  const slide = presentation.appendSlide(layout);
  slide.getBackground().setSolidFill(styleConfig.backgroundColor);

  const titlePlaceholder = slide.getPlaceholders(SlidesApp.PlaceholderType.TITLE)[0];
  if (titlePlaceholder) {
    const tituloDiapositiva = `${eventObj.folio || "S/F"} - ${eventObj.evento || "Actividad sin T√≠tulo"}`;
    titlePlaceholder.asShape().getText().setText(tituloDiapositiva);
    const titleTextRange = titlePlaceholder.asShape().getText();
    titleTextRange.getTextStyle().setFontFamily(styleConfig.titleFontFamily)
      .setFontSize(styleConfig.titleFontSize)
      .setForegroundColor(styleConfig.titleFontColor);
    
    const titleShape = titlePlaceholder.asShape();
    const width = titleShape.getWidth(); const height = titleShape.getHeight();
    const left = titleShape.getLeft(); const top = titleShape.getTop();
    const titleBgShape = slide.insertShape(SlidesApp.ShapeType.RECTANGLE, 
                                          left - styleConfig.titleShapePadding, 
                                          top - styleConfig.titleShapePadding, 
                                          width + (2 * styleConfig.titleShapePadding), 
                                          height + (2 * styleConfig.titleShapePadding));
    titleBgShape.getFill().setSolidFill(styleConfig.titleShapeFillColor);
    titleBgShape.sendToBack();
    titleShape.bringToFront();
  }

  const bodyPlaceholder = slide.getPlaceholders(SlidesApp.PlaceholderType.BODY)[0];
  if (bodyPlaceholder) {
    const bodyText = bodyPlaceholder.asShape().getText();
    bodyText.clear(); 

    let fechaFormateada = eventObj.fechaCompleta;
    if (eventObj.fechaCompleta instanceof Date) {
        fechaFormateada = Utilities.formatDate(eventObj.fechaCompleta, Session.getScriptTimeZone(), "dd 'de' MMMM 'de' yyyy");
    } else if (typeof eventObj.fechaCompleta === 'string' && eventObj.fechaCompleta.match(/^\d{4}-\d{2}-\d{2}/)) { 
        try {
            const dateOnly = eventObj.fechaCompleta.substring(0,10); 
            const dateObjInstance = new Date(dateOnly + "T00:00:00"); 
            if(!isNaN(dateObjInstance)) {
               fechaFormateada = Utilities.formatDate(dateObjInstance, Session.getScriptTimeZone(), "dd 'de' MMMM 'de' yyyy");
            }
        } catch(e) { Logger.log(`Error al formatear fecha '${eventObj.fechaCompleta}': ${e.toString()}`); }
    }
    
    const horaInicioStr = eventObj.horaInicio instanceof Date ? Utilities.formatDate(eventObj.horaInicio, Session.getScriptTimeZone(), "HH:mm") : (eventObj.horaInicio || "");
    const horaFinStr = eventObj.horaFin instanceof Date ? Utilities.formatDate(eventObj.horaFin, Session.getScriptTimeZone(), "HH:mm") : (eventObj.horaFin || "");
    const horario = (horaInicioStr || horaFinStr) ? `${horaInicioStr || "--:--"} - ${horaFinStr || "--:--"}` : "No especificado";

    const baseTextStyle = { fontFamily: styleConfig.bodyFontFamily, fontSize: styleConfig.bodyFontSize, color: styleConfig.bodyFontColor };

    bodyText.appendParagraph(`Fecha: ${fechaFormateada || "No especificada"}  |  Horario: ${horario}`)
            .getRange().getTextStyle().setFontFamily(baseTextStyle.fontFamily).setFontSize(baseTextStyle.fontSize).setForegroundColor(baseTextStyle.color).setBold(true);
    
    bodyText.appendParagraph(`\nTipo: ${eventObj.tipoActividad || "N/A"} | Lugar: ${eventObj.lugarEspecifico || "No especificado"}`)
            .getRange().getTextStyle().setFontFamily(baseTextStyle.fontFamily).setFontSize(baseTextStyle.fontSize).setForegroundColor(baseTextStyle.color);
    
    bodyText.appendParagraph(`\n√Årea Responsable: ${eventObj.areaResponsable || "No especificada"}`)
            .getRange().getTextStyle().setFontFamily(baseTextStyle.fontFamily).setFontSize(baseTextStyle.fontSize).setForegroundColor(baseTextStyle.color);
    
    const prioridadText = eventObj.prioridad || "No especificada";
    let prioridadColor = baseTextStyle.color;
    if (prioridadText.toLowerCase() === 'alta') prioridadColor = styleConfig.accentColors.prioridadAlta;
    else if (prioridadText.toLowerCase() === 'media') prioridadColor = styleConfig.accentColors.prioridadMedia;
    else if (prioridadText.toLowerCase() === 'baja') prioridadColor = styleConfig.accentColors.prioridadBaja;

    const prioridadRun = bodyText.appendParagraph(`\nPrioridad: `).getRange().getTextStyle();
    prioridadRun.setFontFamily(baseTextStyle.fontFamily).setFontSize(baseTextStyle.fontSize).setForegroundColor(baseTextStyle.color);
    bodyText.appendParagraph(prioridadText).getRange().getTextStyle().setFontFamily(baseTextStyle.fontFamily).setFontSize(baseTextStyle.fontSize).setForegroundColor(prioridadColor).setBold(true);

    bodyText.appendParagraph(`\nDescripci√≥n/Objetivos: ${eventObj.descripcionInterna || "No especificada"}`)
            .getRange().getTextStyle().setFontFamily(baseTextStyle.fontFamily).setFontSize(baseTextStyle.fontSize).setForegroundColor(baseTextStyle.color);

    if(eventObj.alineacionPsectorial || eventObj.metaPsectorialNo){
        bodyText.appendParagraph(`\nAlineaci√≥n PSECTORIAL: ${eventObj.alineacionPsectorial || "N/A"} (Meta: ${eventObj.metaPsectorialNo || "N/A"})`)
                .getRange().getTextStyle().setFontFamily(baseTextStyle.fontFamily).setFontSize(baseTextStyle.fontSize - 1).setForegroundColor(baseTextStyle.color);
    }
    bodyText.appendParagraph(`\nEstado Interno: ${eventObj.estadoInterno || "No especificado"}`)
            .getRange().getTextStyle().setFontFamily(baseTextStyle.fontFamily).setFontSize(baseTextStyle.fontSize).setForegroundColor(baseTextStyle.color).setItalic(true);
  }
  // Logger.log(`Diapositiva de evento agregada para: ${eventObj.folio || "S/F"}`); // Removed to reduce log noise
}

/**
 * Adds a final "thank you" or branding slide to the presentation.
 * @param {GoogleAppsScript.Slides.Presentation} presentation The presentation object.
 * @param {string} text The text to display on the end slide.
 * @param {object} styleConfig Configuration object for presentation styling.
 * @param {GoogleAppsScript.Slides.PredefinedLayout} layout The layout to use for the slide.
 * @returns {void}
 */
function addEndSlideToPresentation(presentation, text, styleConfig, layout) {
  const slide = presentation.appendSlide(layout);
  slide.getBackground().setSolidFill(styleConfig.backgroundColor);
  slide.insertTextBox(text, 50, 220, 400, 100) 
    .getText().getTextStyle().setFontFamily(styleConfig.titleFontFamily)
    .setFontSize(20) 
    .setForegroundColor(styleConfig.titleFontColor);
  Logger.log("Diapositiva final agregada.");
}


// --- Main Functions ---

/**
 * Adds a custom menu to the spreadsheet UI when the spreadsheet is opened.
 * @returns {void}
 */
function onOpen() {
  SpreadsheetApp.getUi()
    .createMenu('Herramientas CECAN')
    .addItem('‚öôÔ∏è Configurar Calendario Principal (1 vez)', 'setupCulturalCalendar')
    .addItem('üîÑ Re-ordenar Calendario Principal', 'sortCulturalCalendar')
    .addSeparator()
    .addItem('üìä Crear/Ver Hoja Cronograma Editorial', 'crearHojaCronogramaEditorial')
    .addSeparator()
    .addItem('üñºÔ∏è Generar Presentaci√≥n Interna (Mes)', 'generarPresentacionInterna')
    .addToUi();
}

/**
 * Sets up the main cultural calendar sheet with headers, initial data, formatting, and validations.
 * @returns {void}
 */
function setupCulturalCalendar() {
  const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
  const sheetConfig = CONFIG.calendarSheet;

  const result = ensureSheetExists(sheetConfig.name, sheetConfig.headerNames, true, spreadsheet);
  const sheet = result.sheet;

  const calendarData = [
    ["CECAN-2025-06-001", "EXT-JUN-001", "Junio", 12, "2025-06-12", "Aniversario Luctuoso de Eduardo Capelo", "Conmemoraci√≥n Externa", "Estatal (Nayarit)", "Artista gr√°fico y creador de calendarios.", "Recordar su legado.", "Publicar sobre su trabajo.", "", "Difusi√≥n Cultural", "Redes Sociales", "", "", "Media", "Eje Patrimonio", "2.1", sheetConfig.status.PENDIENTE, "Planeado", "Verificado"],
    ["CECAN-2025-06-002", "INT-JUN-001", "Junio", 15, "2025-06-15", "Reuni√≥n de Planeaci√≥n Festival Amado Nervo", "Reuni√≥n Interna", "Interno CECAN", "", "Definir sedes y artistas principales.", "", "Festival Amado Nervo", "Direcci√≥n Festivales", "Sala de Juntas CECAN", "10:00", "12:00", "Alta", "Eje Festivales", "3.1", "", "Confirmado", "N/A"],
  ];
  populateInitialData(sheet, calendarData, sheetConfig.headerNames);

  const conditionalFormatRules = [
    { 
      columnKey: 'estadoContenidoExt', 
      criteriaType: SpreadsheetApp.BooleanCriteria.TEXT_EQ, 
      criteriaValue: sheetConfig.status.PENDIENTE, 
      backgroundColor: sheetConfig.statusColors.PENDIENTE 
    }
  ];
  applyConditionalFormattingRules(sheet, conditionalFormatRules, sheetConfig.columns, null);


  const validationConfigs = [
    { columnKey: 'estadoContenidoExt', requireValueInList: { listKey: 'status', allowInvalid: false, helpText: "Estado del contenido para difusi√≥n externa." } },
    { columnKey: 'tipoActividad', requireValueInList: { listKey: 'tiposActividad', allowInvalid: false, helpText: "Seleccione el tipo de actividad." } },
    { columnKey: 'prioridad', requireValueInList: { listKey: 'prioridad', allowInvalid: false, helpText: "Defina la prioridad." } },
    { columnKey: 'estadoInterno', requireValueInList: { listKey: 'estadoInterno', allowInvalid: false, helpText: "Estado de gesti√≥n interna de la actividad." } },
    { columnKey: 'alcance', requireValueInList: { listKey: 'alcance', allowInvalid: false, helpText: "Defina el alcance de la actividad." } }
  ];
  const allDropdownListsForValidation = Object.assign({}, sheetConfig.dropdownLists, { status: sheetConfig.status });
  applyDataValidations(sheet, validationConfigs, sheetConfig.columns, allDropdownListsForValidation);
  
  applyNumberFormats(sheet, sheetConfig.numberFormats, sheetConfig.columns);

  sortCulturalCalendar(); 
  autoResizeAllColumns(sheet, sheetConfig.headerNames);

  Logger.log(`Configuraci√≥n inicial completa para ${sheetConfig.name}`);
}

/**
 * Handles onEdit events for the spreadsheet. Specifically, if the "Fecha Completa" or "Hora Inicio"
 * columns in the main calendar sheet are edited, it updates the "Estado Contenido (Externo)"
 * to "Pendiente" if it's empty and then re-sorts the calendar.
 * @param {GoogleAppsScript.Events.SheetsOnEdit} e The event object passed by the onEdit trigger.
 * @returns {void}
 */
function onEdit(e) {
  try {
    const range = e.range;
    const sheet = range.getSheet();
    const calConfig = CONFIG.calendarSheet;

    if (sheet.getName() !== calConfig.name || range.getRow() <= 1) {
      return;
    }

    const editedColumnZeroBased = range.getColumn() - 1; 

    if (editedColumnZeroBased === calConfig.columns.fechaCompleta.index ||
        editedColumnZeroBased === calConfig.columns.horaInicio.index) {
      
      if (range.getValue().toString().trim() !== "") { 
        if (editedColumnZeroBased === calConfig.columns.fechaCompleta.index) {
          const statusCellExt = sheet.getRange(range.getRow(), calConfig.columns.estadoContenidoExt.index + 1);
          if (statusCellExt.getValue().toString().trim() === "") {
            statusCellExt.setValue(calConfig.status.PENDIENTE);
          }
        }
        Utilities.sleep(500); 
        sortCulturalCalendar(); 
      }
    }
  } catch (error) {
    Logger.log(`Error en onEdit (${CONFIG.calendarSheet.name}): ${error.toString()}\nStack: ${error.stack}`);
  }
}

/**
 * Sorts the main cultural calendar sheet based on the default sort criteria defined in CONFIG.
 * @returns {void}
 */
function sortCulturalCalendar() {
  try {
    const sheetConfig = CONFIG.calendarSheet;
    const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(sheetConfig.name);
    
    if (!sheet || sheet.getLastRow() < 2) {
      Logger.log(`Hoja del calendario no encontrada o vac√≠a, no se puede ordenar: ${sheetConfig.name}`);
      return;
    }
    
    const sortObjects = sheetConfig.defaultSort.map(rule => ({
      column: sheetConfig.columns[rule.columnKey].index + 1, 
      ascending: rule.ascending
    }));

    sheet.getRange(2, 1, sheet.getLastRow() - 1, sheet.getLastColumn()).sort(sortObjects);
    Logger.log(`${sheetConfig.name} re-ordenado seg√∫n la configuraci√≥n.`);
  } catch (error) {
    Logger.log(`Error en sortCulturalCalendar: ${error.toString()}\nStack: ${error.stack}`);
  }
}

/**
 * Creates or ensures the "Cronograma Editorial" sheet exists and is formatted correctly.
 * @returns {void}
 */
function crearHojaCronogramaEditorial() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const editorialConfig = CONFIG.editorialSheet;

  const sheetResult = ensureSheetExists(editorialConfig.name, editorialConfig.headerNames, true, ss);
  const sheet = sheetResult.sheet;

  if (sheetResult.isNew) { // Only alert if sheet was newly created
     SpreadsheetApp.getUi().alert(`Se ha creado la hoja "${editorialConfig.name}".`);
  }
  ss.setActiveSheet(sheet); 

  applyEditorialSheetStyling(sheet, editorialConfig.styling, editorialConfig.columnWidths, editorialConfig.headerNames.length);

  const validationsConfigs = [
    { columnKey: 'plataforma', requireValueInList: { listKey: 'plataforma', allowInvalid: false, helpText: "Seleccione la plataforma." } },
    { columnKey: 'estadoPublicacion', requireValueInList: { listKey: 'estadoPublicacion', allowInvalid: false, helpText: "Seleccione el estado." } }
  ];
  applyDataValidations(sheet, validationsConfigs, editorialConfig.columns, editorialConfig.dropdownLists);
  
  const preparedConditionalFormatRules = [];
  for (const statusValue in editorialConfig.conditionalFormattingStatusColors) {
    const color = editorialConfig.conditionalFormattingStatusColors[statusValue];
    const rule = {
      columnKey: 'estadoPublicacion',
      criteriaType: SpreadsheetApp.BooleanCriteria.TEXT_EQ,
      criteriaValue: statusValue,
      backgroundColor: color,
    };
    if (statusValue === "Cancelado") {
      rule.fontColor = "#444444";
    }
    preparedConditionalFormatRules.push(rule);
  }
  applyConditionalFormattingRules(sheet, preparedConditionalFormatRules, editorialConfig.columns, ['estadoPublicacion']);

  applyNumberFormats(sheet, editorialConfig.numberFormatColumns, editorialConfig.columns);
  
  Logger.log(`Sheet "${editorialConfig.name}" creada/formateada.`);
}

/**
 * Generates an internal presentation for a specified month based on data from the calendar sheet.
 * Prompts the user for the month.
 * @returns {void}
 */
function generarPresentacionInterna() {
  const ui = SpreadsheetApp.getUi();
  const result = ui.prompt(
    'Generar Presentaci√≥n Interna',
    'Ingresa el nombre del mes (ej. Mayo, Junio):',
    ui.ButtonSet.OK_CANCEL
  );

  if (result.getSelectedButton() !== ui.Button.OK) return;
  const mesSolicitado = result.getResponseText().trim();
  if (!mesSolicitado) {
    ui.alert('Mes no v√°lido.', 'El nombre del mes no puede estar vac√≠o.', ui.ButtonSet.OK);
    return;
  }

  const calendarConfig = CONFIG.calendarSheet;
  const presentationConfig = CONFIG.internalPresentation;

  const eventosDelMes = getCalendarDataForMonth(
    calendarConfig.name,
    mesSolicitado,
    calendarConfig.columns,
    presentationConfig.requiredCalendarColumns
  );

  if (eventosDelMes === null) { 
    return; 
  }
  if (eventosDelMes.length === 0) {
    ui.alert(`No se encontraron actividades para "${mesSolicitado}" en el calendario interno.`);
    return;
  }

  try {
    const presentationTitle = `Agenda Interna CECAN - ${mesSolicitado} ${new Date().getFullYear()}`;
    const presentation = SlidesApp.create(presentationTitle);
    Logger.log(`Presentaci√≥n Interna creada: ${presentation.getName()} (ID: ${presentation.getId()})`);

    addTitleSlideToPresentation(
      presentation,
      presentationTitle,
      `Actividades y Gesti√≥n de ${mesSolicitado}`,
      presentationConfig
    );

    eventosDelMes.forEach((eventoRow) => {
      addEventSlideToPresentation(
        presentation,
        eventoRow,
        presentationConfig,
        SlidesApp.PredefinedLayout.TITLE_AND_BODY
      );
    });

    addEndSlideToPresentation(
      presentation,
      presentationConfig.endSlideText, 
      presentationConfig,
      SlidesApp.PredefinedLayout.BLANK
    );
    
    const presentationUrl = presentation.getUrl();
    Logger.log(`Presentaci√≥n Interna lista: ${presentationUrl}`);
    ui.alert('Presentaci√≥n Interna Generada', `La presentaci√≥n "${presentationTitle}" ha sido creada.\nPuedes acceder a ella aqu√≠: ${presentationUrl}`, ui.ButtonSet.OK);

  } catch (error) {
    Logger.log(`Error al generar presentaci√≥n interna: ${error.toString()}\nStack: ${error.stack}`);
    ui.alert('Error', `Ocurri√≥ un error al generar la presentaci√≥n interna: ${error.message}`, ui.ButtonSet.OK);
  }
}
